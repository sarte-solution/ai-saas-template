---
title: æ”¯ä»˜å’Œè´¦å•
---

AI SaaS Template é›†æˆäº†å®Œæ•´çš„ Stripe æ”¯ä»˜ç³»ç»Ÿï¼Œæä¾›ä¼ä¸šçº§çš„è®¢é˜…ç®¡ç†ã€è‡ªåŠ¨è´¦å•å¤„ç†ã€Webhook äº‹ä»¶å¤„ç†å’Œç”¨æˆ·å‹å¥½çš„è´¦å•ä»ªè¡¨æ¿ã€‚æ”¯æŒå¤šç§ä»˜è´¹è®¡åˆ’ã€çµæ´»çš„è®¡è´¹å‘¨æœŸå’Œå®Œå–„çš„æ”¯ä»˜ä½“éªŒã€‚

## ç³»ç»Ÿæ¦‚è¿°

### æ ¸å¿ƒç‰¹æ€§

- **ğŸ”’ å®‰å…¨æ”¯ä»˜**: åŸºäº Stripe çš„ PCI åˆè§„æ”¯ä»˜å¤„ç†
- **ğŸ“Š è®¢é˜…ç®¡ç†**: çµæ´»çš„è®¢é˜…è®¡åˆ’å’Œè‡ªåŠ¨ç»­è´¹
- **ğŸ’³ å¤šç§æ”¯ä»˜æ–¹å¼**: æ”¯æŒä¿¡ç”¨å¡ã€å€Ÿè®°å¡å’Œæ•°å­—é’±åŒ…
- **ğŸ”„ Webhook é›†æˆ**: å®æ—¶äº‹ä»¶å¤„ç†å’ŒçŠ¶æ€åŒæ­¥
- **ğŸ“ˆ ä½¿ç”¨é‡è®¡è´¹**: åŸºäº AI ä½¿ç”¨é‡çš„è®¡è´¹æ¨¡å¼
- **ğŸ§¾ å‘ç¥¨ç®¡ç†**: è‡ªåŠ¨ç”Ÿæˆå’Œå‘é€å‘ç¥¨
- **âš¡ å³æ—¶ç”Ÿæ•ˆ**: è®¢é˜…çŠ¶æ€çš„å®æ—¶æ›´æ–°

### æŠ€æœ¯æ¶æ„

```mermaid
graph TB
    A[ç”¨æˆ·è®¢é˜…] --> B[Stripe Checkout]
    B --> C[æ”¯ä»˜å¤„ç†]
    C --> D[Webhook äº‹ä»¶]
    D --> E[tRPC API]
    E --> F[æ•°æ®åº“æ›´æ–°]
    F --> G[ç”¨æˆ·çŠ¶æ€åŒæ­¥]
    
    subgraph "Stripe æœåŠ¡"
        H[Customer ç®¡ç†]
        I[Subscription ç®¡ç†]
        J[Payment å¤„ç†]
        K[Invoice ç”Ÿæˆ]
    end
    
    B --> H
    C --> I
    C --> J
    D --> K
```

## Stripe é…ç½®

### ç¯å¢ƒå˜é‡è®¾ç½®

```bash
# Stripe é…ç½®
STRIPE_SECRET_KEY="sk_test_..."  # ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ sk_live_
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="pk_test_..."  # ç”Ÿäº§ç¯å¢ƒä½¿ç”¨ pk_live_
STRIPE_WEBHOOK_SECRET="whsec_..."

# å¯é€‰ï¼šStripe Connect (å¤šå•†æˆ·æ”¯æŒ)
STRIPE_CONNECT_CLIENT_ID="ca_..."
```

### Stripe å®¢æˆ·ç«¯åˆå§‹åŒ–

```typescript
// src/lib/stripe/config.ts
import Stripe from 'stripe'
import { env } from '@/env'

export const stripe = new Stripe(env.STRIPE_SECRET_KEY, {
  apiVersion: '2023-10-16',
  typescript: true,
})

// å®¢æˆ·ç«¯ Stripe Promise
export const getStripe = () => {
  return loadStripe(env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY)
}
```

### è®¢é˜…è®¡åˆ’é…ç½®

```typescript
// src/lib/payments/plans.ts
export const SUBSCRIPTION_PLANS = {
  free: {
    id: 'free',
    name: 'å…è´¹ç‰ˆ',
    description: 'ä¸ªäººç”¨æˆ·å’Œå°å‹é¡¹ç›®',
    price: 0,
    interval: 'month' as const,
    features: [
      '10 æ¬¡ AI å¯¹è¯/æœˆ',
      'åŸºç¡€æ¨¡å‹è®¿é—®',
      'ç¤¾åŒºæ”¯æŒ',
      'åŸºç¡€æ–‡æ¡£',
    ],
    limits: {
      aiUsage: 10,
      projects: 1,
      storage: 100 * 1024 * 1024, // 100MB
    },
    stripePriceId: null, // å…è´¹è®¡åˆ’æ— éœ€ Stripe Price ID
  },
  basic: {
    id: 'basic',
    name: 'åŸºç¡€ç‰ˆ',
    description: 'é€‚åˆä¸ªäººä¸“ä¸šä½¿ç”¨',
    price: 19.99,
    interval: 'month' as const,
    features: [
      '1000 æ¬¡ AI å¯¹è¯/æœˆ',
      'æ‰€æœ‰ AI æ¨¡å‹',
      'é‚®ä»¶æ”¯æŒ',
      'ä½¿ç”¨ç»Ÿè®¡',
      'å¯¼å‡ºåŠŸèƒ½',
    ],
    limits: {
      aiUsage: 1000,
      projects: 5,
      storage: 1 * 1024 * 1024 * 1024, // 1GB
    },
    stripePriceId: 'price_basic_monthly',
  },
  pro: {
    id: 'pro',
    name: 'ä¸“ä¸šç‰ˆ',
    description: 'å›¢é˜Ÿå’Œä¼ä¸šç”¨æˆ·',
    price: 49.99,
    interval: 'month' as const,
    features: [
      'æ— é™ AI å¯¹è¯',
      'ä¼˜å…ˆæ¨¡å‹è®¿é—®',
      'ä¼˜å…ˆæ”¯æŒ',
      'é«˜çº§åˆ†æ',
      'å›¢é˜Ÿåä½œ',
      'API è®¿é—®',
    ],
    limits: {
      aiUsage: -1, // æ— é™åˆ¶
      projects: -1, // æ— é™åˆ¶
      storage: 10 * 1024 * 1024 * 1024, // 10GB
    },
    stripePriceId: 'price_pro_monthly',
  },
} as const

export type PlanId = keyof typeof SUBSCRIPTION_PLANS
export type Plan = typeof SUBSCRIPTION_PLANS[PlanId]

// å¹´ä»˜è®¡åˆ’ (20% æŠ˜æ‰£)
export const YEARLY_PLANS = {
  basic_yearly: {
    ...SUBSCRIPTION_PLANS.basic,
    id: 'basic_yearly',
    price: 191.90, // 12 * 19.99 * 0.8
    interval: 'year' as const,
    stripePriceId: 'price_basic_yearly',
  },
  pro_yearly: {
    ...SUBSCRIPTION_PLANS.pro,
    id: 'pro_yearly',
    price: 479.90, // 12 * 49.99 * 0.8
    interval: 'year' as const,
    stripePriceId: 'price_pro_yearly',
  },
} as const
```

## æ•°æ®åº“é›†æˆ

### æ”¯ä»˜ç›¸å…³æ•°æ®è¡¨

```typescript
// src/lib/db/schema.ts (æ”¯ä»˜ç›¸å…³è¡¨)
export const subscriptions = pgTable('subscriptions', {
  id: text('id').primaryKey().$defaultFn(() => createId()),
  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  
  // Stripe ç›¸å…³
  stripeSubscriptionId: text('stripe_subscription_id').unique(),
  stripeCustomerId: text('stripe_customer_id'),
  stripePriceId: text('stripe_price_id'),
  
  // è®¢é˜…ä¿¡æ¯
  planId: text('plan_id').notNull(),
  status: text('status').notNull(), // active, canceled, past_due, trialing
  currentPeriodStart: timestamp('current_period_start'),
  currentPeriodEnd: timestamp('current_period_end'),
  cancelAtPeriodEnd: boolean('cancel_at_period_end').default(false),
  
  // è¯•ç”¨æœŸ
  trialStart: timestamp('trial_start'),
  trialEnd: timestamp('trial_end'),
  
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow().$onUpdateFn(() => new Date()),
}, (table) => ({
  userIdIdx: index('subscriptions_user_id_idx').on(table.userId),
  stripeSubscriptionIdIdx: index('subscriptions_stripe_subscription_id_idx').on(table.stripeSubscriptionId),
}))

export const invoices = pgTable('invoices', {
  id: text('id').primaryKey().$defaultFn(() => createId()),
  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  subscriptionId: text('subscription_id').references(() => subscriptions.id, { onDelete: 'set null' }),
  
  // Stripe å‘ç¥¨ä¿¡æ¯
  stripeInvoiceId: text('stripe_invoice_id').unique().notNull(),
  stripePaymentIntentId: text('stripe_payment_intent_id'),
  
  // å‘ç¥¨è¯¦æƒ…
  amount: integer('amount').notNull(), // é‡‘é¢(åˆ†)
  currency: text('currency').notNull().default('usd'),
  status: text('status').notNull(), // draft, open, paid, void, uncollectible
  
  // å‘ç¥¨é“¾æ¥
  hostedInvoiceUrl: text('hosted_invoice_url'),
  invoicePdf: text('invoice_pdf'),
  
  // è®¡è´¹å‘¨æœŸ
  periodStart: timestamp('period_start'),
  periodEnd: timestamp('period_end'),
  
  createdAt: timestamp('created_at').notNull().defaultNow(),
  updatedAt: timestamp('updated_at').notNull().defaultNow().$onUpdateFn(() => new Date()),
}, (table) => ({
  userIdIdx: index('invoices_user_id_idx').on(table.userId),
  stripeInvoiceIdIdx: index('invoices_stripe_invoice_id_idx').on(table.stripeInvoiceId),
}))

export const paymentMethods = pgTable('payment_methods', {
  id: text('id').primaryKey().$defaultFn(() => createId()),
  userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  
  // Stripe æ”¯ä»˜æ–¹å¼ä¿¡æ¯
  stripePaymentMethodId: text('stripe_payment_method_id').unique().notNull(),
  
  // æ”¯ä»˜æ–¹å¼è¯¦æƒ…
  type: text('type').notNull(), // card, bank_account, etc.
  brand: text('brand'), // visa, mastercard, etc.
  last4: text('last4'),
  expiryMonth: integer('expiry_month'),
  expiryYear: integer('expiry_year'),
  
  // çŠ¶æ€
  isDefault: boolean('is_default').default(false),
  
  createdAt: timestamp('created_at').notNull().defaultNow(),
}, (table) => ({
  userIdIdx: index('payment_methods_user_id_idx').on(table.userId),
  stripePaymentMethodIdIdx: index('payment_methods_stripe_payment_method_id_idx').on(table.stripePaymentMethodId),
}))
```

## tRPC æ”¯ä»˜è·¯ç”±

### æ”¯ä»˜ç›¸å…³ API

```typescript
// src/lib/trpc/routers/payment.ts
import { z } from 'zod'
import { TRPCError } from '@trpc/server'
import { createTRPCRouter, protectedProcedure } from '../server'
import { stripe } from '@/lib/stripe/config'
import { SUBSCRIPTION_PLANS } from '@/lib/payments/plans'
import { 
  createSubscription as createDbSubscription,
  updateSubscription,
  getActiveSubscription,
  createInvoice as createDbInvoice,
} from '@/lib/db/queries/payments'

export const paymentRouter = createTRPCRouter({
  // è·å–å½“å‰è®¢é˜…
  getCurrentSubscription: protectedProcedure.query(async ({ ctx }) => {
    const subscription = await getActiveSubscription(ctx.user.id)
    return subscription
  }),

  // åˆ›å»º Checkout Session
  createCheckoutSession: protectedProcedure
    .input(z.object({
      planId: z.enum(['basic', 'pro', 'basic_yearly', 'pro_yearly']),
      successUrl: z.string().url().optional(),
      cancelUrl: z.string().url().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const plan = SUBSCRIPTION_PLANS[input.planId as keyof typeof SUBSCRIPTION_PLANS]
      if (!plan || !plan.stripePriceId) {
        throw new TRPCError({ code: 'BAD_REQUEST', message: 'Invalid plan' })
      }

      // åˆ›å»ºæˆ–è·å– Stripe å®¢æˆ·
      let customer = await stripe.customers.search({
        query: `email:'${ctx.user.email}'`,
      })

      if (customer.data.length === 0) {
        const newCustomer = await stripe.customers.create({
          email: ctx.user.email,
          name: ctx.user.name || undefined,
          metadata: {
            userId: ctx.user.id,
            clerkId: ctx.user.clerkId,
          },
        })
        customer.data = [newCustomer]
      }

      // åˆ›å»º Checkout Session
      const session = await stripe.checkout.sessions.create({
        customer: customer.data[0].id,
        mode: 'subscription',
        line_items: [
          {
            price: plan.stripePriceId,
            quantity: 1,
          },
        ],
        success_url: input.successUrl || `${process.env.NEXT_PUBLIC_APP_URL}/dashboard?success=true`,
        cancel_url: input.cancelUrl || `${process.env.NEXT_PUBLIC_APP_URL}/pricing`,
        metadata: {
          userId: ctx.user.id,
          planId: input.planId,
        },
      })

      return {
        sessionId: session.id,
        url: session.url,
      }
    }),

  // åˆ›å»ºå®¢æˆ·é—¨æˆ·ä¼šè¯
  createPortalSession: protectedProcedure
    .input(z.object({
      returnUrl: z.string().url().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const subscription = await getActiveSubscription(ctx.user.id)
      if (!subscription?.stripeCustomerId) {
        throw new TRPCError({ code: 'NOT_FOUND', message: 'No active subscription found' })
      }

      const session = await stripe.billingPortal.sessions.create({
        customer: subscription.stripeCustomerId,
        return_url: input.returnUrl || `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/billing`,
      })

      return {
        url: session.url,
      }
    }),

  // å–æ¶ˆè®¢é˜…
  cancelSubscription: protectedProcedure
    .input(z.object({
      immediate: z.boolean().default(false),
    }))
    .mutation(async ({ ctx, input }) => {
      const subscription = await getActiveSubscription(ctx.user.id)
      if (!subscription?.stripeSubscriptionId) {
        throw new TRPCError({ code: 'NOT_FOUND', message: 'No active subscription found' })
      }

      if (input.immediate) {
        // ç«‹å³å–æ¶ˆ
        await stripe.subscriptions.cancel(subscription.stripeSubscriptionId)
      } else {
        // åœ¨è®¡è´¹å‘¨æœŸç»“æŸæ—¶å–æ¶ˆ
        await stripe.subscriptions.update(subscription.stripeSubscriptionId, {
          cancel_at_period_end: true,
        })
      }

      return { success: true }
    }),

  // æ¢å¤è®¢é˜…
  resumeSubscription: protectedProcedure.mutation(async ({ ctx }) => {
    const subscription = await getActiveSubscription(ctx.user.id)
    if (!subscription?.stripeSubscriptionId) {
      throw new TRPCError({ code: 'NOT_FOUND', message: 'No active subscription found' })
    }

    await stripe.subscriptions.update(subscription.stripeSubscriptionId, {
      cancel_at_period_end: false,
    })

    return { success: true }
  }),

  // è·å–å‘ç¥¨å†å²
  getInvoices: protectedProcedure
    .input(z.object({
      limit: z.number().min(1).max(100).default(20),
      page: z.number().min(1).default(1),
    }))
    .query(async ({ ctx, input }) => {
      const offset = (input.page - 1) * input.limit
      
      const invoices = await db
        .select()
        .from(invoicesTable)
        .where(eq(invoicesTable.userId, ctx.user.id))
        .orderBy(desc(invoicesTable.createdAt))
        .limit(input.limit)
        .offset(offset)

      const total = await db
        .select({ count: count() })
        .from(invoicesTable)
        .where(eq(invoicesTable.userId, ctx.user.id))

      return {
        invoices,
        total: total[0].count,
        page: input.page,
        limit: input.limit,
        totalPages: Math.ceil(total[0].count / input.limit),
      }
    }),

  // è·å–æ”¯ä»˜æ–¹å¼
  getPaymentMethods: protectedProcedure.query(async ({ ctx }) => {
    const methods = await db
      .select()
      .from(paymentMethodsTable)
      .where(eq(paymentMethodsTable.userId, ctx.user.id))
      .orderBy(desc(paymentMethodsTable.isDefault), desc(paymentMethodsTable.createdAt))

    return methods
  }),
})
```

## Webhook äº‹ä»¶å¤„ç†

### Webhook ç«¯ç‚¹

```typescript
// src/app/api/webhooks/stripe/route.ts
import { headers } from 'next/headers'
import { NextRequest, NextResponse } from 'next/server'
import { stripe } from '@/lib/stripe/config'
import { env } from '@/env'
import {
  handleSubscriptionCreated,
  handleSubscriptionUpdated,
  handleSubscriptionDeleted,
  handleInvoicePaymentSucceeded,
  handleInvoicePaymentFailed,
  handleCustomerUpdated,
} from '@/lib/payments/webhook-handlers'

export async function POST(req: NextRequest) {
  const body = await req.text()
  const signature = headers().get('stripe-signature')

  if (!signature) {
    return NextResponse.json(
      { error: 'Missing stripe-signature header' },
      { status: 400 }
    )
  }

  let event: Stripe.Event

  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      env.STRIPE_WEBHOOK_SECRET
    )
  } catch (err) {
    console.error('Webhook signature verification failed:', err)
    return NextResponse.json(
      { error: 'Invalid signature' },
      { status: 400 }
    )
  }

  try {
    switch (event.type) {
      case 'customer.subscription.created':
        await handleSubscriptionCreated(event.data.object as Stripe.Subscription)
        break

      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription)
        break

      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription)
        break

      case 'invoice.payment_succeeded':
        await handleInvoicePaymentSucceeded(event.data.object as Stripe.Invoice)
        break

      case 'invoice.payment_failed':
        await handleInvoicePaymentFailed(event.data.object as Stripe.Invoice)
        break

      case 'customer.updated':
        await handleCustomerUpdated(event.data.object as Stripe.Customer)
        break

      default:
        console.log(`Unhandled event type: ${event.type}`)
    }

    return NextResponse.json({ received: true })
  } catch (error) {
    console.error('Webhook handler error:', error)
    return NextResponse.json(
      { error: 'Webhook handler failed' },
      { status: 500 }
    )
  }
}
```

### Webhook å¤„ç†å™¨

```typescript
// src/lib/payments/webhook-handlers.ts
import type Stripe from 'stripe'
import { eq } from 'drizzle-orm'
import { db } from '@/lib/db'
import { users, subscriptions, invoices } from '@/lib/db/schema'
import { getUserByClerkId } from '@/lib/db/queries/users'

export async function handleSubscriptionCreated(subscription: Stripe.Subscription) {
  const customer = await stripe.customers.retrieve(subscription.customer as string)
  
  if (customer.deleted) return

  const userId = customer.metadata?.userId
  if (!userId) {
    console.error('No userId found in customer metadata')
    return
  }

  await db.insert(subscriptions).values({
    userId,
    stripeSubscriptionId: subscription.id,
    stripeCustomerId: subscription.customer as string,
    stripePriceId: subscription.items.data[0]?.price.id,
    planId: subscription.metadata?.planId || 'basic',
    status: subscription.status,
    currentPeriodStart: new Date(subscription.current_period_start * 1000),
    currentPeriodEnd: new Date(subscription.current_period_end * 1000),
    trialStart: subscription.trial_start ? new Date(subscription.trial_start * 1000) : null,
    trialEnd: subscription.trial_end ? new Date(subscription.trial_end * 1000) : null,
  })

  // æ›´æ–°ç”¨æˆ·è®¢é˜…çŠ¶æ€
  await db
    .update(users)
    .set({
      planType: subscription.metadata?.planId || 'basic',
      subscriptionStatus: subscription.status,
      updatedAt: new Date(),
    })
    .where(eq(users.id, userId))
}

export async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  await db
    .update(subscriptions)
    .set({
      status: subscription.status,
      currentPeriodStart: new Date(subscription.current_period_start * 1000),
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      cancelAtPeriodEnd: subscription.cancel_at_period_end,
      updatedAt: new Date(),
    })
    .where(eq(subscriptions.stripeSubscriptionId, subscription.id))

  // åŒæ­¥æ›´æ–°ç”¨æˆ·è¡¨
  const [dbSubscription] = await db
    .select({ userId: subscriptions.userId })
    .from(subscriptions)
    .where(eq(subscriptions.stripeSubscriptionId, subscription.id))

  if (dbSubscription) {
    await db
      .update(users)
      .set({
        subscriptionStatus: subscription.status,
        updatedAt: new Date(),
      })
      .where(eq(users.id, dbSubscription.userId))
  }
}

export async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  await db
    .update(subscriptions)
    .set({
      status: 'canceled',
      updatedAt: new Date(),
    })
    .where(eq(subscriptions.stripeSubscriptionId, subscription.id))

  // æ›´æ–°ç”¨æˆ·è®¡åˆ’ä¸ºå…è´¹ç‰ˆ
  const [dbSubscription] = await db
    .select({ userId: subscriptions.userId })
    .from(subscriptions)
    .where(eq(subscriptions.stripeSubscriptionId, subscription.id))

  if (dbSubscription) {
    await db
      .update(users)
      .set({
        planType: 'free',
        subscriptionStatus: 'canceled',
        updatedAt: new Date(),
      })
      .where(eq(users.id, dbSubscription.userId))
  }
}

export async function handleInvoicePaymentSucceeded(invoice: Stripe.Invoice) {
  if (!invoice.subscription) return

  const customer = await stripe.customers.retrieve(invoice.customer as string)
  if (customer.deleted) return

  const userId = customer.metadata?.userId
  if (!userId) return

  // åˆ›å»ºæˆ–æ›´æ–°å‘ç¥¨è®°å½•
  await db
    .insert(invoices)
    .values({
      userId,
      stripeInvoiceId: invoice.id,
      stripePaymentIntentId: invoice.payment_intent as string,
      amount: invoice.amount_paid,
      currency: invoice.currency,
      status: invoice.status || 'paid',
      hostedInvoiceUrl: invoice.hosted_invoice_url,
      invoicePdf: invoice.invoice_pdf,
      periodStart: invoice.period_start ? new Date(invoice.period_start * 1000) : null,
      periodEnd: invoice.period_end ? new Date(invoice.period_end * 1000) : null,
    })
    .onConflictDoUpdate({
      target: invoices.stripeInvoiceId,
      set: {
        status: invoice.status || 'paid',
        hostedInvoiceUrl: invoice.hosted_invoice_url,
        invoicePdf: invoice.invoice_pdf,
        updatedAt: new Date(),
      },
    })

  console.log(`Payment succeeded for invoice ${invoice.id}`)
}

export async function handleInvoicePaymentFailed(invoice: Stripe.Invoice) {
  console.log(`Payment failed for invoice ${invoice.id}`)
  
  // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å‘é€é€šçŸ¥é‚®ä»¶çš„é€»è¾‘
  // æˆ–è€…æ›´æ–°ç”¨æˆ·çš„è´¦æˆ·çŠ¶æ€
}

export async function handleCustomerUpdated(customer: Stripe.Customer) {
  const userId = customer.metadata?.userId
  if (!userId) return

  // åŒæ­¥å®¢æˆ·ä¿¡æ¯åˆ°æ•°æ®åº“
  await db
    .update(users)
    .set({
      email: customer.email || undefined,
      name: customer.name || undefined,
      updatedAt: new Date(),
    })
    .where(eq(users.id, userId))
}
```

## æ”¯ä»˜ç»„ä»¶

### å®šä»·é¡µé¢

```tsx
// src/components/payment/pricing-page.tsx
'use client'

import { useState } from 'react'
import { Check, Sparkles } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Switch } from '@/components/ui/switch'
import { api } from '@/lib/trpc/client'
import { SUBSCRIPTION_PLANS, YEARLY_PLANS } from '@/lib/payments/plans'
import { useAuth } from '@clerk/nextjs'
import { toast } from '@/components/ui/use-toast'

export function PricingPage() {
  const [isYearly, setIsYearly] = useState(false)
  const { isSignedIn } = useAuth()
  
  const createCheckoutSession = api.payment.createCheckoutSession.useMutation({
    onSuccess: (data) => {
      if (data.url) {
        window.location.href = data.url
      }
    },
    onError: (error) => {
      toast({
        title: 'åˆ›å»ºè®¢é˜…å¤±è´¥',
        description: error.message,
        variant: 'destructive',
      })
    },
  })

  const plans = isYearly ? 
    { ...SUBSCRIPTION_PLANS, ...YEARLY_PLANS } : 
    SUBSCRIPTION_PLANS

  const handleSubscribe = (planId: string) => {
    if (!isSignedIn) {
      window.location.href = '/auth/sign-in'
      return
    }

    if (planId === 'free') {
      window.location.href = '/dashboard'
      return
    }

    createCheckoutSession.mutate({ planId })
  }

  return (
    <div className="container mx-auto py-16">
      <div className="text-center mb-12">
        <h1 className="text-4xl font-bold mb-4">é€‰æ‹©æ‚¨çš„è®¡åˆ’</h1>
        <p className="text-xl text-muted-foreground mb-8">
          ä»å…è´¹å¼€å§‹ï¼Œéšæ—¶å‡çº§ä»¥è§£é”æ›´å¤šåŠŸèƒ½
        </p>
        
        <div className="flex items-center justify-center gap-4 mb-8">
          <span className={!isYearly ? 'font-semibold' : 'text-muted-foreground'}>
            æœˆä»˜
          </span>
          <Switch
            checked={isYearly}
            onCheckedChange={setIsYearly}
          />
          <span className={isYearly ? 'font-semibold' : 'text-muted-foreground'}>
            å¹´ä»˜
          </span>
          {isYearly && (
            <Badge variant="secondary" className="ml-2">
              èŠ‚çœ 20%
            </Badge>
          )}
        </div>
      </div>

      <div className="grid md:grid-cols-3 gap-8 max-w-6xl mx-auto">
        {Object.entries(plans).map(([planId, plan]) => {
          if (isYearly && planId === 'free') return null
          if (isYearly && planId === 'basic') return null
          if (isYearly && planId === 'pro') return null
          if (!isYearly && planId.includes('yearly')) return null

          const isPopular = planId === 'pro' || planId === 'pro_yearly'

          return (
            <Card
              key={planId}
              className={`relative ${isPopular ? 'border-primary shadow-lg scale-105' : ''}`}
            >
              {isPopular && (
                <div className="absolute -top-4 left-1/2 -translate-x-1/2">
                  <Badge className="bg-primary text-primary-foreground px-3 py-1">
                    <Sparkles className="w-4 h-4 mr-1" />
                    æœ€å—æ¬¢è¿
                  </Badge>
                </div>
              )}

              <CardHeader className="text-center pb-8">
                <CardTitle className="text-2xl">{plan.name}</CardTitle>
                <CardDescription className="text-sm">
                  {plan.description}
                </CardDescription>
                <div className="mt-4">
                  <span className="text-4xl font-bold">
                    {plan.price === 0 ? 'å…è´¹' : `Â¥${plan.price}`}
                  </span>
                  {plan.price > 0 && (
                    <span className="text-muted-foreground ml-1">
                      /{plan.interval === 'month' ? 'æœˆ' : 'å¹´'}
                    </span>
                  )}
                </div>
              </CardHeader>

              <CardContent className="space-y-6">
                <ul className="space-y-3">
                  {plan.features.map((feature, index) => (
                    <li key={index} className="flex items-start gap-3">
                      <Check className="w-5 h-5 text-green-500 shrink-0 mt-0.5" />
                      <span className="text-sm">{feature}</span>
                    </li>
                  ))}
                </ul>

                <Button
                  className="w-full"
                  variant={isPopular ? 'default' : 'outline'}
                  onClick={() => handleSubscribe(planId)}
                  disabled={createCheckoutSession.isLoading}
                >
                  {planId === 'free' ? 'å¼€å§‹ä½¿ç”¨' : 'ç«‹å³è®¢é˜…'}
                </Button>
              </CardContent>
            </Card>
          )
        })}
      </div>

      <div className="text-center mt-12">
        <p className="text-sm text-muted-foreground">
          æ‰€æœ‰è®¡åˆ’éƒ½åŒ…å« 7 å¤©å…è´¹è¯•ç”¨ã€‚éšæ—¶å¯ä»¥å–æ¶ˆè®¢é˜…ã€‚
        </p>
      </div>
    </div>
  )
}
```

### è´¦å•ä»ªè¡¨æ¿

```tsx
// src/components/payment/billing-dashboard.tsx
'use client'

import { useState } from 'react'
import { Calendar, CreditCard, Download, ExternalLink, AlertCircle } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { api } from '@/lib/trpc/client'
import { SUBSCRIPTION_PLANS } from '@/lib/payments/plans'
import { toast } from '@/components/ui/use-toast'

export function BillingDashboard() {
  const [cancelLoading, setCancelLoading] = useState(false)
  
  const { data: subscription, refetch: refetchSubscription } = api.payment.getCurrentSubscription.useQuery()
  const { data: invoices } = api.payment.getInvoices.useQuery({ limit: 10 })
  const { data: paymentMethods } = api.payment.getPaymentMethods.useQuery()

  const createPortalSession = api.payment.createPortalSession.useMutation({
    onSuccess: (data) => {
      window.location.href = data.url
    },
    onError: (error) => {
      toast({
        title: 'æ‰“å¼€å®¢æˆ·é—¨æˆ·å¤±è´¥',
        description: error.message,
        variant: 'destructive',
      })
    },
  })

  const cancelSubscription = api.payment.cancelSubscription.useMutation({
    onSuccess: () => {
      toast({
        title: 'è®¢é˜…å·²å–æ¶ˆ',
        description: 'æ‚¨çš„è®¢é˜…å°†åœ¨å½“å‰è®¡è´¹å‘¨æœŸç»“æŸæ—¶å–æ¶ˆ',
      })
      refetchSubscription()
    },
    onError: (error) => {
      toast({
        title: 'å–æ¶ˆè®¢é˜…å¤±è´¥',
        description: error.message,
        variant: 'destructive',
      })
    },
  })

  const resumeSubscription = api.payment.resumeSubscription.useMutation({
    onSuccess: () => {
      toast({
        title: 'è®¢é˜…å·²æ¢å¤',
        description: 'æ‚¨çš„è®¢é˜…å°†ç»§ç»­æ­£å¸¸è®¡è´¹',
      })
      refetchSubscription()
    },
    onError: (error) => {
      toast({
        title: 'æ¢å¤è®¢é˜…å¤±è´¥',
        description: error.message,
        variant: 'destructive',
      })
    },
  })

  const plan = subscription ? SUBSCRIPTION_PLANS[subscription.planId as keyof typeof SUBSCRIPTION_PLANS] : null

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold">è´¦å•ç®¡ç†</h1>
        <p className="text-muted-foreground">
          ç®¡ç†æ‚¨çš„è®¢é˜…ã€æ”¯ä»˜æ–¹å¼å’Œè´¦å•å†å²
        </p>
      </div>

      {/* å½“å‰è®¢é˜…çŠ¶æ€ */}
      {subscription && (
        <Card>
          <CardHeader>
            <CardTitle>å½“å‰è®¢é˜…</CardTitle>
            <CardDescription>æ‚¨çš„è®¢é˜…è¯¦æƒ…å’ŒçŠ¶æ€</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="font-semibold text-lg">{plan?.name}</h3>
                <p className="text-muted-foreground">
                  Â¥{plan?.price}/{plan?.interval === 'month' ? 'æœˆ' : 'å¹´'}
                </p>
              </div>
              <Badge 
                variant={subscription.status === 'active' ? 'default' : 'secondary'}
              >
                {subscription.status === 'active' ? 'æ¿€æ´»' : subscription.status}
              </Badge>
            </div>

            {subscription.cancelAtPeriodEnd && (
              <Alert>
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>
                  æ‚¨çš„è®¢é˜…å°†åœ¨ {subscription.currentPeriodEnd?.toLocaleDateString()} å–æ¶ˆ
                </AlertDescription>
              </Alert>
            )}

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 pt-4 border-t">
              <div>
                <p className="text-sm font-medium">å½“å‰è®¡è´¹å‘¨æœŸ</p>
                <p className="text-sm text-muted-foreground">
                  {subscription.currentPeriodStart?.toLocaleDateString()} - {subscription.currentPeriodEnd?.toLocaleDateString()}
                </p>
              </div>
              <div>
                <p className="text-sm font-medium">ä¸‹æ¬¡æ‰£è´¹</p>
                <p className="text-sm text-muted-foreground">
                  {subscription.cancelAtPeriodEnd 
                    ? 'ä¸ä¼šè‡ªåŠ¨ç»­è´¹' 
                    : subscription.currentPeriodEnd?.toLocaleDateString()
                  }
                </p>
              </div>
            </div>

            <div className="flex gap-2 pt-4">
              <Button
                variant="outline"
                onClick={() => createPortalSession.mutate({})}
                disabled={createPortalSession.isLoading}
              >
                ç®¡ç†è®¢é˜…
              </Button>
              
              {subscription.cancelAtPeriodEnd ? (
                <Button
                  variant="outline"
                  onClick={() => resumeSubscription.mutate()}
                  disabled={resumeSubscription.isLoading}
                >
                  æ¢å¤è®¢é˜…
                </Button>
              ) : (
                <Button
                  variant="outline"
                  onClick={() => cancelSubscription.mutate({ immediate: false })}
                  disabled={cancelSubscription.isLoading}
                >
                  å–æ¶ˆè®¢é˜…
                </Button>
              )}
            </div>
          </CardContent>
        </Card>
      )}

      {/* æ”¯ä»˜æ–¹å¼ */}
      <Card>
        <CardHeader>
          <CardTitle>æ”¯ä»˜æ–¹å¼</CardTitle>
          <CardDescription>ç®¡ç†æ‚¨çš„æ”¯ä»˜æ–¹å¼</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {paymentMethods && paymentMethods.length > 0 ? (
            paymentMethods.map((method) => (
              <div
                key={method.id}
                className="flex items-center justify-between p-3 border rounded-lg"
              >
                <div className="flex items-center gap-3">
                  <CreditCard className="h-5 w-5" />
                  <div>
                    <p className="font-medium">
                      {method.brand?.toUpperCase()} â€¢â€¢â€¢â€¢ {method.last4}
                    </p>
                    <p className="text-sm text-muted-foreground">
                      è¿‡æœŸæ—¶é—´ {method.expiryMonth}/{method.expiryYear}
                    </p>
                  </div>
                </div>
                <div className="flex items-center gap-2">
                  {method.isDefault && (
                    <Badge variant="secondary">é»˜è®¤</Badge>
                  )}
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => createPortalSession.mutate({})}
                  >
                    ç®¡ç†
                  </Button>
                </div>
              </div>
            ))
          ) : (
            <p className="text-muted-foreground">æš‚æ— æ”¯ä»˜æ–¹å¼</p>
          )}

          <Button
            variant="outline"
            onClick={() => createPortalSession.mutate({})}
            disabled={createPortalSession.isLoading}
          >
            æ·»åŠ æ”¯ä»˜æ–¹å¼
          </Button>
        </CardContent>
      </Card>

      {/* è´¦å•å†å² */}
      <Card>
        <CardHeader>
          <CardTitle>è´¦å•å†å²</CardTitle>
          <CardDescription>æŸ¥çœ‹æ‚¨çš„å†å²å‘ç¥¨å’Œæ”¯ä»˜è®°å½•</CardDescription>
        </CardHeader>
        <CardContent>
          {invoices && invoices.invoices.length > 0 ? (
            <div className="space-y-3">
              {invoices.invoices.map((invoice) => (
                <div
                  key={invoice.id}
                  className="flex items-center justify-between p-3 border rounded-lg"
                >
                  <div className="flex items-center gap-3">
                    <Calendar className="h-5 w-5" />
                    <div>
                      <p className="font-medium">
                        Â¥{(invoice.amount / 100).toFixed(2)}
                      </p>
                      <p className="text-sm text-muted-foreground">
                        {invoice.createdAt.toLocaleDateString()}
                      </p>
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    <Badge
                      variant={invoice.status === 'paid' ? 'default' : 'secondary'}
                    >
                      {invoice.status === 'paid' ? 'å·²æ”¯ä»˜' : invoice.status}
                    </Badge>
                    {invoice.hostedInvoiceUrl && (
                      <Button variant="ghost" size="sm" asChild>
                        <a
                          href={invoice.hostedInvoiceUrl}
                          target="_blank"
                          rel="noopener noreferrer"
                        >
                          <ExternalLink className="h-4 w-4" />
                        </a>
                      </Button>
                    )}
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <p className="text-muted-foreground">æš‚æ— è´¦å•è®°å½•</p>
          )}
        </CardContent>
      </Card>
    </div>
  )
}
```

## ä½¿ç”¨é‡è¿½è¸ª

### AI ä½¿ç”¨é‡ç®¡ç†

```typescript
// src/lib/usage/ai-usage.ts
import { eq, and } from 'drizzle-orm'
import { db } from '@/lib/db'
import { users } from '@/lib/db/schema'
import { SUBSCRIPTION_PLANS } from '@/lib/payments/plans'

export async function checkAIUsageLimit(userId: string): Promise<boolean> {
  const [user] = await db
    .select({
      aiUsageCount: users.aiUsageCount,
      aiUsageLimit: users.aiUsageLimit,
      planType: users.planType,
    })
    .from(users)
    .where(eq(users.id, userId))

  if (!user) return false

  // ä¸“ä¸šç‰ˆç”¨æˆ·æ— é™åˆ¶
  if (user.planType === 'pro') return true

  return user.aiUsageCount < user.aiUsageLimit
}

export async function incrementAIUsage(userId: string): Promise<void> {
  await db
    .update(users)
    .set({
      aiUsageCount: sql`${users.aiUsageCount} + 1`,
      updatedAt: new Date(),
    })
    .where(eq(users.id, userId))
}

export async function resetMonthlyUsage(userId: string): Promise<void> {
  await db
    .update(users)
    .set({
      aiUsageCount: 0,
      updatedAt: new Date(),
    })
    .where(eq(users.id, userId))
}

export async function getUsageStats(userId: string) {
  const [user] = await db
    .select({
      aiUsageCount: users.aiUsageCount,
      aiUsageLimit: users.aiUsageLimit,
      planType: users.planType,
    })
    .from(users)
    .where(eq(users.id, userId))

  if (!user) return null

  const plan = SUBSCRIPTION_PLANS[user.planType as keyof typeof SUBSCRIPTION_PLANS]
  const usagePercentage = user.planType === 'pro' 
    ? 0 // æ— é™åˆ¶
    : (user.aiUsageCount / user.aiUsageLimit) * 100

  return {
    current: user.aiUsageCount,
    limit: user.planType === 'pro' ? -1 : user.aiUsageLimit,
    percentage: usagePercentage,
    planName: plan?.name || 'æœªçŸ¥è®¡åˆ’',
    isUnlimited: user.planType === 'pro',
  }
}
```

## æµ‹è¯•å’Œå¼€å‘

### æœ¬åœ°å¼€å‘è®¾ç½®

```bash
# å®‰è£… Stripe CLI
npm install -g @stripe/stripe-cli

# ç™»å½• Stripe
stripe login

# è½¬å‘ Webhook äº‹ä»¶åˆ°æœ¬åœ°
stripe listen --forward-to localhost:3000/api/webhooks/stripe

# è§¦å‘æµ‹è¯•äº‹ä»¶
stripe trigger customer.subscription.created
stripe trigger invoice.payment_succeeded
```

### æµ‹è¯•å¡å·

```typescript
// æµ‹è¯•ç”¨çš„ä¿¡ç”¨å¡å·
export const STRIPE_TEST_CARDS = {
  // æˆåŠŸæ”¯ä»˜
  success: '4242424242424242',
  visa: '4000056655665556',
  mastercard: '5555555555554444',
  amex: '378282246310005',
  
  // å¤±è´¥åœºæ™¯
  declined: '4000000000000002',
  insufficientFunds: '4000000000009995',
  expired: '4000000000000069',
  
  // 3D Secure
  require3DS: '4000002500003155',
  
  // ä¸­å›½é“¶è”
  unionpay: '6200000000000005',
} as const
```

## å®‰å…¨è€ƒè™‘

### Webhook å®‰å…¨éªŒè¯

```typescript
// éªŒè¯ Webhook ç­¾å
const signature = headers().get('stripe-signature')
if (!signature) {
  return NextResponse.json({ error: 'Missing signature' }, { status: 400 })
}

try {
  const event = stripe.webhooks.constructEvent(
    body,
    signature,
    process.env.STRIPE_WEBHOOK_SECRET!
  )
  // å¤„ç†äº‹ä»¶...
} catch (err) {
  return NextResponse.json({ error: 'Invalid signature' }, { status: 400 })
}
```

### ç¯å¢ƒå˜é‡ä¿æŠ¤

```typescript
// env.ts ä¸­çš„éªŒè¯
server: {
  STRIPE_SECRET_KEY: z.string().min(1),
  STRIPE_WEBHOOK_SECRET: z.string().min(1),
},
client: {
  NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: z.string().min(1),
}
```

## éƒ¨ç½²é…ç½®

### ç”Ÿäº§ç¯å¢ƒ Webhook

1. åœ¨ Stripe æ§åˆ¶å°åˆ›å»º Webhook ç«¯ç‚¹
2. URL: `https://your-domain.com/api/webhooks/stripe`
3. é€‰æ‹©äº‹ä»¶ç±»å‹ï¼š
   - `customer.subscription.created`
   - `customer.subscription.updated`
   - `customer.subscription.deleted`
   - `invoice.payment_succeeded`
   - `invoice.payment_failed`
4. å¤åˆ¶ Webhook ç­¾åå¯†é’¥åˆ°ç¯å¢ƒå˜é‡

è¿™ä¸ªå®Œæ•´çš„æ”¯ä»˜è´¦å•ç³»ç»Ÿä¸º AI SaaS åº”ç”¨æä¾›äº†ä¼ä¸šçº§çš„è®¢é˜…ç®¡ç†èƒ½åŠ›ï¼Œæ”¯æŒçµæ´»çš„å®šä»·æ¨¡å¼ã€è‡ªåŠ¨åŒ–çš„è´¦å•å¤„ç†å’Œå®Œå–„çš„ç”¨æˆ·ä½“éªŒã€‚